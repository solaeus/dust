use std::fmt::{self, Display, Formatter};

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, Eq, PartialEq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum Token {
    // End of file
    Eof,

    // Represents characrers that cannot be used in Dust source code
    Unknown,

    // Hard-coded values
    TrueValue,
    FalseValue,
    ByteValue,
    CharacterValue,
    FloatValue,
    IntegerValue,
    StringValue,

    // Paths to declared items or variables
    Identifier,

    // Keywords
    Any,
    Async,
    Bool,
    Break,
    Byte,
    Cell,
    Char,
    Const,
    Else,
    Float,
    Fn,
    If,
    Int,
    Let,
    List,
    Loop,
    Map,
    Mod,
    Mut,
    Return,
    Str,
    Struct,
    Use,
    While,

    // Symbols (operators and punctuation)
    ArrowThin,
    Asterisk,
    BangEqual,
    Bang,
    Colon,
    Comma,
    Dot,
    DoubleAmpersand,
    DoubleColon,
    DoubleDot,
    DoubleEqual,
    DoublePipe,
    Equal,
    Greater,
    GreaterEqual,
    LeftCurlyBrace,
    LeftSquareBracket,
    LeftParenthesis,
    Less,
    LessEqual,
    Minus,
    MinusEqual,
    Percent,
    PercentEqual,
    Plus,
    PlusEqual,
    RightCurlyBrace,
    RightSquareBracket,
    RightParenthesis,
    Semicolon,
    Slash,
    SlashEqual,
    StarEqual,

    // Whitespace
    Newline,
    Space,
    Tab,
}

impl Token {
    pub fn is_whitespace(&self) -> bool {
        matches!(self, Token::Newline | Token::Space | Token::Tab)
    }
}

impl Display for Token {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            Token::Eof => write!(f, "end of file"),
            Token::Unknown => write!(f, "unknown token"),
            Token::TrueValue => write!(f, "true"),
            Token::FalseValue => write!(f, "false"),
            Token::ByteValue => write!(f, "byte value"),
            Token::CharacterValue => write!(f, "character value"),
            Token::FloatValue => write!(f, "float value"),
            Token::IntegerValue => write!(f, "integer value"),
            Token::StringValue => write!(f, "string value"),
            Token::Identifier => write!(f, "identifier"),
            Token::Any => write!(f, "'any' keyword"),
            Token::Async => write!(f, "'async' keyword"),
            Token::Bool => write!(f, "'bool' keyword"),
            Token::Break => write!(f, "'break' keyword"),
            Token::Byte => write!(f, "'byte' keyword"),
            Token::Cell => write!(f, "'cell' keyword"),
            Token::Char => write!(f, "'char' keyword"),
            Token::Const => write!(f, "'const' keyword"),
            Token::Else => write!(f, "'else' keyword"),
            Token::Float => write!(f, "'float' keyword"),
            Token::Fn => write!(f, "'fn' keyword"),
            Token::If => write!(f, "'if' keyword"),
            Token::Int => write!(f, "'int' keyword"),
            Token::Let => write!(f, "'let' keyword"),
            Token::List => write!(f, "'list' keyword"),
            Token::Loop => write!(f, "'loop' keyword"),
            Token::Map => write!(f, "'map' keyword"),
            Token::Mod => write!(f, "'mod' keyword"),
            Token::Mut => write!(f, "'mut' keyword"),
            Token::Return => write!(f, "'return' keyword"),
            Token::Str => write!(f, "'str' keyword"),
            Token::Struct => write!(f, "'struct' keyword"),
            Token::Use => write!(f, "'use' keyword"),
            Token::While => write!(f, "'while' keyword"),
            Token::ArrowThin => write!(f, "-> symbol"),
            Token::Asterisk => write!(f, "* symbol"),
            Token::BangEqual => write!(f, "!= symbol"),
            Token::Bang => write!(f, "! symbol"),
            Token::Colon => write!(f, ": symbol"),
            Token::Comma => write!(f, ", symbol"),
            Token::Dot => write!(f, ". symbol"),
            Token::DoubleAmpersand => write!(f, "&& symbol"),
            Token::DoubleColon => write!(f, ":: symbol"),
            Token::DoubleDot => write!(f, ".. symbol"),
            Token::DoubleEqual => write!(f, "== symbol"),
            Token::DoublePipe => write!(f, "|| symbol"),
            Token::Equal => write!(f, "= symbol"),
            Token::Greater => write!(f, "> symbol"),
            Token::GreaterEqual => write!(f, ">= symbol"),
            Token::LeftCurlyBrace => write!(f, "{{ symbol"),
            Token::LeftSquareBracket => write!(f, "[ symbol"),
            Token::LeftParenthesis => write!(f, "( symbol"),
            Token::Less => write!(f, "< symbol"),
            Token::LessEqual => write!(f, "<= symbol"),
            Token::Minus => write!(f, "- symbol"),
            Token::MinusEqual => write!(f, "-= symbol"),
            Token::Percent => write!(f, "% symbol"),
            Token::PercentEqual => write!(f, "%= symbol"),
            Token::Plus => write!(f, "+ symbol"),
            Token::PlusEqual => write!(f, "+= symbol"),
            Token::RightCurlyBrace => write!(f, "}} symbol"),
            Token::RightSquareBracket => write!(f, "] symbol"),
            Token::RightParenthesis => write!(f, ") symbol"),
            Token::Semicolon => write!(f, "; symbol"),
            Token::Slash => write!(f, "/ symbol"),
            Token::SlashEqual => write!(f, "/= symbol"),
            Token::StarEqual => write!(f, "*= symbol"),
            Token::Newline => write!(f, "newline"),
            Token::Space => write!(f, "space"),
            Token::Tab => write!(f, "tab"),
        }
    }
}
